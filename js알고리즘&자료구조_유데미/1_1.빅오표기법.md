# Big O notation



# 빅오표기법

* 여러가지 코드들을 일반적으로 서로 비교하고 성능을 평가하는 방법을 뜻함.
* 코드 안의 어느 부분에서 문제가 생기는지 쉽게 알아볼 수 있다.
* 어떤 알고리즘이던 빅오로 생각해서 효율적인 알고리즘 코드를 찾는게 중요하고, 면접에서도 나올 수 있는 질문 중 하나!
* 작성한 코드를 더 잘 이해하고, 효율적인 좋은 코드를 작성하는데 도움을 준다.

## 더 좋은 코드란??

* 더 빠른 실행 속도를 의미하는가
* 메모리를 더 적게 사용하는게 좋은 코드인가
* 더 짧고, 읽기 쉬운 코드일까

<br>
<br>
<br>

## 코드 실행 시간 측정하기

```js
function uptoAdd(n){
    let total = 0;
    for(let i = 1; i < n; i++){
        total += 1;
    }
    return total;
}

let t1 = performance.now();     //타이밍 function
uptoAdd(1000000000);     // 10억까지의 수들의 합.
let t2 = performance.now();     // 밀리세컨으로 측정됨
console.log(`Time Elapsed : ${(t2 - t1) / 1000} seconds`)     //밀리세컨이므로 1000으로 나눠주면 초

```

![aws](/Image/js_algo/1.PNG)

> 10억까지의 수들을 돌렸을 때 대략 "1초"의 시간이 걸린걸 볼 수 있다.

> 실행할 때 마다 시간이 달라지는데, 프로세스마다 컴퓨터마다 이 값은 다르게 나올 수 있다.

```js
function uptoAdd(n){
    return n * (n + 1) / 2      // 위와 같은 결과, 다른 해결 방식
}

let t1 = performance.now();
uptoAdd(1000000000);     // 1억까지의 수들의 합.
let t2 = performance.now();     // 밀리세컨으로 측정됨
console.log(`Time Elapsed : ${(t2 - t1) / 1000} seconds`)     //밀리세컨이므로 1000으로 나눠주면 초
```

![aws](/Image/js_algo/2.PNG)

> 똑같은 데이터를 다루고 같은 결과를 도출하지만, 1번의 코드와 비교할 수 없을 정도로 작은 수행시간이 도출되었다.

> 따라서 훨씬 효율적이라고 볼 수 있다.


### 시간의 문제

🔥 이런 식으로 수동으로 시간을 측정하는 코드를 짜 넣고, 빼주는게 정확한 시간을 측정 할 수 있을까!??!

* 완전히 믿을 수 없다. -> 기기마다 다른 사양을 보이기 때문에, 시간 측정에도 차이가 난다/ 어떤 플랫폼을 사용하느냐에서도 차이가 날 수 있음.

* 같은 코드도 프로세스마다 다른 시간이 측정됨으로 정확한 코드 실행의 시간은 아니다.

* 굉장히 빠른 알고리즘은 매우 작은 시간이 측정되므로, 그것도 정확하지 않을 확률이 높다.

* 이렇게 부정확한 시간측정이지만 그 말이 위의 코드같은 예시에서 코드1번이 코드2번보다 더 빨라질 수도 있겠다는 말은 아니다. -> 코드 실행 속도의 우열은 확실하다.(효율적인 코드의 우열은 존재한다.)


>> 이런식으로 코드안에 시간을 측정하는 코드를 또 집어 넣어서 시간을 측정해 비교하는 방법은 매우 비효율적이므로, 빅오표기법을 사용하는 것!!


<br>
<br>
<br>

## 연산 갯수 세기

* 연산의 갯수는 시간과 비례.

```js
function uptoAdd(n){
    return n * (n + 1) / 2      // 위와 같은 결과, 다른 해결 방식
}
```

> 2번의 코드를 보면, 3번의 연산(*, +, /)이 존재하고, n이 몇이냐에 관계 없이 연산의 갯수는 정해져 있다. 


```js
function uptoAdd(n){
    let total = 0;
    for(let i = 1; i < n; i++){
        total += 1;
    }
    return total;
}
```

> 반면, 1번의 코드는 n에 따라서 연산의 갯수가 크게 달라지게 된다. (loop 안에 연산은 + 하나이지만, n번을 연산하게 됨)

> 사실, 엄밀히 말하자면, loop를 위해, i++ 하는 것도 연산이므로, 더 많은 연산을 하게 된다.

> 더 엄밀히 들어가보자.
> 실제로는 "="도 연산이므로, 1번 코드의 함수 안에는, 훨씬 더 많은 연산이 들어가게 된다.

🔥 하지만.. 중요한 건 이런 세세한 연산의 수가 아니라, 전체적인 추세를 보는것.
-> 1번의 코드 경우에는, n이 커질수록 연산의 갯수도 비례해서( 실제 : 5n+2 -> 몰라도됨)커진다 정도로만 알면된다.

<br>
<br>
<br>

# 빅오 표현식

```js
function uptoAdd(n){
    return n * (n + 1) / 2      // 위와 같은 결과, 다른 해결 방식
}
```

> O(1)

```js
function uptoAdd(n){
    let total = 0;
    for(let i = 1; i < n; i++){
        total += 1;
    }
    return total;
}
```

> O(n)

> n값에 계수가 붙는다 해도, 사실상 n으로 단순화 시켜서 표기함. <br>
> 2번의 코드는 n에 따라 선형적으로 증가되는 함수 그래프를 상상하면 된다.


```js
function printAllPairs(n){
    for(var i = 0; i < n; i++){         //O(n)
        for(var j = 0; j < n; j++>){        //O(n)
            console.log(i , j);
        }
    }
}
```
> O(n<sup>2</sup>)

> 이러한 중첩반복문인 형태에서, O(n)인 연산이 중첩되었으므로 연산갯수는 n*n이 된다.<br>
> 이럴때, 이차곡선의 그래프를 생각. -> 선형적 그래프가 아님.

<br>
<br>
<br>

## 빅오 표현식의 단순화

> 앞서 본것과 같이, 빅오표현식은 결국 시간복잡도를 그래프로 보았을 때, 그 추세를 보는 것이므로, <br>
> 계수와 상수는 생략하고 표기한다. 

* O(2n) -> O(n)
* O(n + 10) -> O(n)
* O(1000n + 50) -> O(n)
* O(500) -> O(1)
* O(13n<sup>2</sup>) -> O(n<sup>2</sup>)
* O(n<sup>2</sup> + 5n + 8) -> O(n<sup>2</sup>)

> 결국의 추세만 중요하다는 건 마지막의 예를 보았을 때, <br>
> n 에 1000이 들어갔다고 생각해보자. <br>
> O(105008) -> O(100000) : 이므로 작은 수들 대입했을 때보다 차이가 작아지는 걸 볼 수 있다. <br>
> n에 10억을 대입했다고 생각해보자.....그 차이는 정말 미세해진다.

## 빅오 표현을 쉽게 적용할 수 있는 규칙.

1. 사칙연산은 모두 상수. -> 덧셈, 뺄셈, 곱셈, 나눗셈을 포함.
2. 변수의 배정은 모두 상수. -> 컴퓨터가 변수에 값을 배정하는데 걸리는 시간은 비슷함.<br>
    (int a = 10 이던 x = 10000 이던 수의 크기에 상관없이 시간은 비슷.)
3. 배열의 인덱스를 이용해서 찾는 시간과 객체를 다룰떄, 데이터를 접근하기 위해서 키가 있다면 그것 또한 상수.
4. 루프가 존재한다면, 루프의 길이 * 루프안의 시간

###  예시

```js
function logAtLeast5(n){
    for(var i = 1; i <= Math.max(5,n); i++){
        console.log(i);
    }
}
```
> O(n) <br>
> n이 5보다 클때만 n까지 출력하고 그 이하인 경우에는 적어도 5까지 출력하는 함수이다. <br>
> 항상 무한대로 n을 보냈을 때 어떨지 상상하자. 그러면 5가 아무 의미 없다는 걸 알수 있고 따라서, n의 시간복잡도를 가진다고 할 수 잇다.

```js
function logAtMost5(n) {
    for(var i =1; i<= Math.min(5, n); i++){
        console.log(i);
    }
}
```
> O(1)



![aws](/Image/js_algo/3.PNG)


<br>
<br>
<br>
<br>
<br>

# 공간 복잡도

: 공간, 사용되는 메모리에 신경쓰기

* auxiliary space complexity(보조 공간 복잡도) : 입력 되는 값을 제외한, 알고리즘 자체가 필요로 하는 공간을 의미. -> 실상 우리가 흔히 말하는 공간복잡도!!🐶

> 입력이 커질수록 n의 값이 커질텐데, 그건 시간복잡도로 계산이 가능하므로, 입력에 따라 n의 값이 커지는 공간 이외의(입력 이외의) 알고리즘 자체가 공간에 어떤 영향을 주는지에만 초점을 두면 됨.


## 공간 복잡도 규칙 - JS관점

1. boolean, numbers(상수), undefined, null은 js에서 모두 불변 공간.
    -> boolean이 false든, true든/ numbers가 1이든 10000이든 똑같은 공간을 차지.
2. 문자열은 조금 다르다. O(n)의 공간을 가짐 -> 50자의 문자열을 가진다면, 1자인 문자열보다 50배의 공간을 더 차지.
3. reference타입, 배열, 객체도 O(n)의 공간 복잡도. -> n은 배열의 길이이거나 객체의 키 갯수.


### 예시

```js
function sum(arr){
    let total = 0;
    for(let i = 0; i< arr.length; i++){
        total += arr[i];
    }
    return total;
}
```

> O(1)  <br>
> 공간을 차지하는 건, total과 i 변수 뿐이고, arr의 길이가 더 길어진다 하더라도 새롭게 생성되는 공간이 없으므로. 


```js
function double(arr){
    let newArr = [];
    for(let i = 0; i < arr.length; i++){
        newArr.push(2 * arr[i]);
    }
    return newArr;
}
```
> O(n)  <br>
> n개의 배열이 들어오면, 새로운 n짜리의 배열이 만들어짐으로(i = 0이나 처음에 생성하는 빈배열은 신경쓸 필요 X)

























