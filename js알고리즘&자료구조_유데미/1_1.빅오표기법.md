# Big O notation



# 빅오표기법

* 여러가지 코드들을 일반적으로 서로 비교하고 성능을 평가하는 방법을 뜻함.
* 코드 안의 어느 부분에서 문제가 생기는지 쉽게 알아볼 수 있다.
* 어떤 알고리즘이던 빅오로 생각해서 효율적인 알고리즘 코드를 찾는게 중요하고, 면접에서도 나올 수 있는 질문 중 하나!
* 작성한 코드를 더 잘 이해하고, 효율적인 좋은 코드를 작성하는데 도움을 준다.

## 더 좋은 코드란??

* 더 빠른 실행 속도를 의미하는가
* 메모리를 더 적게 사용하는게 좋은 코드인가
* 더 짧고, 읽기 쉬운 코드일까

<br>
<br>
<br>

# 코드 실행 시간 측정하기

```js
function uptoAdd(n){
    let total = 0;
    for(let i = 1; i < n; i++){
        total += 1;
    }
    return total;
}

let t1 = performance.now();     //타이밍 function
uptoAdd(1000000000);     // 10억까지의 수들의 합.
let t2 = performance.now();     // 밀리세컨으로 측정됨
console.log(`Time Elapsed : ${(t2 - t1) / 1000} seconds`)     //밀리세컨이므로 1000으로 나눠주면 초

```

![aws](/Image/js_algo/1.PNG)

> 10억까지의 수들을 돌렸을 때 대략 "1초"의 시간이 걸린걸 볼 수 있다.

> 실행할 때 마다 시간이 달라지는데, 프로세스마다 컴퓨터마다 이 값은 다르게 나올 수 있다.

```js
function uptoAdd(n){
    return n * (n + 1) / 2      // 위와 같은 결과, 다른 해결 방식
}

let t1 = performance.now();
uptoAdd(1000000000);     // 1억까지의 수들의 합.
let t2 = performance.now();     // 밀리세컨으로 측정됨
console.log(`Time Elapsed : ${(t2 - t1) / 1000} seconds`)     //밀리세컨이므로 1000으로 나눠주면 초
```

![aws](/Image/js_algo/2.PNG)

> 똑같은 데이터를 다루고 같은 결과를 도출하지만, 1번의 코드와 비교할 수 없을 정도로 작은 수행시간이 도출되었다.

> 따라서 훨씬 효율적이라고 볼 수 있다.

### 시간의 문제

🔥 이런 식으로 수동으로 시간을 측정하는 코드를 짜 넣고, 빼주는게 정확한 시간을 측정 할 수 있을까!??!

* 완전히 믿을 수 없다. -> 기기마다 다른 사양을 보이기 때문에, 시간 측정에도 차이가 난다/ 어떤 플랫폼을 사용하느냐에서도 차이가 날 수 있음.

* 같은 코드도 프로세스마다 다른 시간이 측정됨으로 정확한 코드 실행의 시간은 아니다.

* 굉장히 빠른 알고리즘은 매우 작은 시간이 측정되므로, 그것도 정확하지 않을 확률이 높다.

* 이렇게 부정확한 시간측정이지만 그 말이 위의 코드같은 예시에서 코드1번이 코드2번보다 더 빨라질 수도 있겠다는 말은 아니다. -> 코드 실행 속도의 우열은 확실하다.(효율적인 코드의 우열은 존재한다.)


>> 이런식으로 코드안에 시간을 측정하는 코드를 또 집어 넣어서 시간을 측정해 비교하는 방법은 매우 비효율적이므로, 빅오표기법을 사용하는 것!!


<br>
<br>
<br>

# 연산 갯수 세기













