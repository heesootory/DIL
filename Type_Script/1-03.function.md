# Function

<br>
<br>

## Call Signatures

* 함수의 타입을 우리가 커스터마이징.

* 타입만 지정한 함수를 만들어서, 재사용이 가능하게 타입만을 지정해 준다.

* 타입만으로 함수의 틀을 만들어 놓는 과정.
    -> 이후 함수를 사용할때 지정된 타입에 맞춰 구현해서 사용.

```ts
//일반 함수형
type Add(a: number, b : number) : number {
    return a+b      
    // 파라미터의 타입을 number로 정해준것만으로도 return 타입이 자동으로 number로 지정됨.
    // 함수의 타입 () : number {}을 안해줘도 자동으로 인식
}

// <call Signatures> 만들기.
// 길게 적는 방식 - 오버로딩을 위해.
type Add = {
    (a: number, b : number) : number
}
//짧게 적는 방식 -"람다형"
type Add = (a:number, b:number) => number;

const add: Add = (a, b) => a + b
// 이 함수자체의 타입을 지정해 줘서, 매개변수나 리턴값들을 모두 타입 추론이 가능해짐.
  
```
 
<br>
<br>

## Overloading

* 앞으로 다른 사람들이 만들어논 외부 라이브러리나 패키지를 많이 사용하게 되는데, 그럴때 오버로딩을 엄청 많이 사용하게된다.

* 서로 다른 여러가지 call signatures가 있는 함수.


```ts
type Config = {
    path : string,
    state : object
}

type Push = {
    (path : string): void
    (config : Config) : void       // Config라는 객체형
}

const push : Push = (config) => {
    if(typeof config === "string") { console.log(config) }
    else{
        console.log(config.path, config.state)
    }
}

```

* 다른 여러개의 argument를 가지고 있을 때 발생하는 효과.

```ts
// 다른 call signatures에 파라미터의 갯수도 다른 경우 
type Add = {
    (a:number, b:number) : number
    (a:number, b:number, c:number) : number,
}
// 파라미터로 a,b가 올수도있고, a,b,c가 올 수도 있는 상황에서 c는 옵션이므로 c의 타입은 ?를 이용해서 지정해줘야함.
const add: Add = (a, b, c?:number) => {
    if(c) return a+b+c
    return a+b
}

add(1,2)
add(1,2,3)
```


## Polymorphism

* "poly" = many = multi = much = several

* "morpos" = structure = form.

* 여러가지 모양(구조)라는 의미.

### Concrete Type 
> 우리가 여태 흔히 사용했던 number, boolean, string, void, unknown 등의 타입들.

### generic 이란???

* placeholder와 같은 의미.



```ts
type SuperPrint = {     // 3개의 call signiture
    (arr: number[]) : void
    (arr: boolean[]) : void
    (arr: string[]) : void
}
// 숫자로 구성된 배열을 받고, return은 없음.


const superPrint : SuperPrint = (arr) => {
    arr.forEach(i => console.log(i))
}
// 배열을 받아서, 원소를 하나식 출력. -> 실제 구현 함수에서는 배열의 타입이 지정되어있지 않다.

superPrint([1,2,3,4])
superPrint([true, false, true, false])
superPrint(["a", "b", "c"])
```

> 이렇게 정형화된 배열만이 아니라, 어떤 타입도 들어갈 수 있는 배열을 출력하고 싶다면!?

```ts
//superPrint([1,2,true, "abc"]) -> 현재 함수로는 불가.



```






























