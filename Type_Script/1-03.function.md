# Function

<br>
<br>

## Call Signatures

* 함수의 타입을 우리가 커스터마이징.

```ts
//일반 함수형
type Add = {
    (a: number, b : number) : number
}
//람다형
type Add = (a:number, b:number) => number;

const add: Add = (a, b) => a + b
// 이 함수자체의 타입을 지정해 줘서, 매개변수나 리턴값들을 모두 타입 추론이 가능해짐.
  
```
 
<br>
<br>

## Overloading

* 앞으로 다른 사람들이 만들어논 외부 라이브러리나 패키지를 많이 사용하게 되는데, 그럴때 오버로딩을 엄청 많이 사용하게된다.

* 여러가지 call signatures가 있는 함수.


```ts
type Config = {
    path : string,
    state : object
}

type Push = {
    (path : string): void
    (config : Config) : void
}

const push : Push (config) => {
    if(typeof config === "string") { console.log(config) }
    else{
        console.log(config.path, config.state)
    }
}

```

* 다른 여러개의 argument를 가지고 있을 때 발생하는 효과.

```ts
// 다른 call signatures에 파라미터의 갯수도 다른 경우 
type Add = {
    (a:number, b:number) : number
    (a:number, b:number, c:number) : number,
}
// 파라미터로 a,b가 올수도있고, a,b,c가 올 수도 있는 상황에서 c는 옵션이므로 c의 타입은 ?를 이용해서 지정해줘야함.
const add: Add = (a, b, c?:number) => {
    if(c) return a+b+c
    return a+b
}

add(1,2)
add(1,2,3)
```


































