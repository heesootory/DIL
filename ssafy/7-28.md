# 제너릭






# 예외처리

개발자
jvm
OS
HW

* 위의 계층안에서 발생하는 에러가 아니고, 기본본체 밖의 문제가 발생하여, 생기는 문제 -> error (하지만 대응은 가능하므로.)
* 그게 아닌 문제 -> IOException등의 에러
* runtime Exception -> 걍 개발자 실수


## checked error




## unchecked error






# comparable

 * main함수 안에 구현할시에는 일회성 사용을 목적으로 둔다.



 # 해시
 
 * 지문이라고 볼 수잇다
 * 적은양의 정보로 많은 양으이 정보를 구별하기 위한 정보.

 ex) set에서의 비교 -> equals를 오버라이딩해서 같은걸로 나와도 해시값이 달라서  set에서는 다른값으로 취급


*  해시값은 항상 객체보다 적기 때문에 충돌은 날 수 밖에 없다.
    -> 따라서 충돌을 안나게 하려면 어떻게하는지에 대한 고민을 한다.

* birthday_problem
* 비둘기집원리 - 집은 어떤 비둘기가 들어오는지 몰라야 한다.
*  sha-512 : 2의 512승의 비둘기집

* 사례 :  블록체인의 노드






# 입출력


* out과 err는 통로가 다름 -> 속도차이가 나서 순서대로 출력이 안될수있음.

```java
import java.io.*;

public class FileOutTest {
	public static void main(String[] args) {
		try(FileOutputStream fo = new FileOutputStream("ggg2.jpg");
				FileInputStream fi = new FileInputStream("ggg.jpg")){
			 /**
			  * 1. write(int) : 1바이트를 스트림에 출력
			  * 2. write(byte[]) : byte배열 내용을 스트림에 출력
			  * 3. write(byte[], offset, size) : byte배열내용을 offset만큼 건너뛰고 size만큼	
			  */
			
//			fo.write(259);
//			fo.flush();
			
			byte[] buf = new byte[1024 * 8];
//			int len = fi.read(buf);
//			fo.write(buf);
//			fo.flush();
//			System.out.println(len);	// 버퍼에 복사하는 용량 출력
			
			byte key = 33;
			int len = 0;
			while((len = fi.read(buf)) != -1) {
//				for(int i =0; i< len; i++) {
//					// XOR 연산자를 사용해서 암호화, 복호화(파일 내용 변경)
//					buf[i] ^= key;
//				}
				// 기본 복사
				fo.write(buf, 0, len);
				fo.flush();
				
			}
			
			
			/**
			 * 1. read() : 1바이트를 읽고 읽은 바이트를 반환(정수), 읽을게 없으면 -1
			 * 2. read(byte[]) : byte배열 크기 만큼을 읽어서 byte배열에 쓰고, 읽은 길이를 반환.
			 * 3. read(byte[], offset, len) : offset만큼 건너뛰고, len만큼 읽어서 byte배열에 채우고 그 길이을 반환/
			 */
			
			
			
			// 위는 3, 아래는 2가 많이 쓰임.
		}catch(FileNotFoundException e){
			e.printStackTrace();
		}catch(Exception e) {
			e.printStackTrace();
		}
		
		
		
		
	}
}

```





















