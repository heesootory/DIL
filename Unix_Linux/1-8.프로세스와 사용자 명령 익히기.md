# 8. 프로세스와 사용자 명령 익히기.

## 프로세스의 개념과 종류

* 프로세스의 종류
    - 시스템 프로세스 : 유닉스 운영에 필요한 기능 수행.
    - 사용자 프로세스 : 사용자들이 실행시킨 프로세스


* 프로세스

| 프로세스 | 설명 |
|-|-|
| 데몬(daemon) | 유닉스 커널에 의해 실행되는 프로세스로 특정 서비스 제공 | 
| 부모(parent) | 자식 프로세스를 만드는 프로세스 | 
| 자식(child) | 부모에 의해 실행된 프로세스 <br> 실행이 끝나면 부모 프로세스에 결과를 돌려주고 종료. |
| 고아(orphan) | 실행 도중에 부모 프로세스가 종료된 프로세스 |
| 좀비(zonbie) | 부모프로세스가 종료 처리를 하지 않은 프로세스 <br> 종료가 되었음에도 할당된 시스템 자원이 회수 되지 않은 상태 | 


## 프로세스 관리 명령

### 프로세스 목록 보기

#### ps

```bash
$ ps [옵션]
```

* process status
* 프로세스의 정보를 출력
    - PID, 터미널, CPU 시간, 명령어
* 옵션
    - -e : 시스템에 있는 모든 프로세스 정보 출력.
    - -f : 프로세스에 대한 자세한 정보 출력.
    - -u UID : 특정 사용자에 대한 모든 프로세스 출력.

* ps -f 출력 정보

| 항목 | 의미 |
|-|-|
| UID | 프로세스를 실행시킨 사용자 ID |
| PID | 프로세스 번호 |
| PPID | 부모 프로세스 번호 |
| C | 프로세스의 우선순위 |
| STIME | 프로세스의 시작 시간을 '시:분:초' 형식으로 출력 |
| TTY | 프로세스의 실행된 단말기 종류와 번호 |
| CMD | 실행되고 있는 프로그램 이름(명령) |


### 프로세스 종료

#### kill

```bash
$ kill [옵션] pid
```

* PID 로 지정한 프로세스에게 시그널을 보냄.
    - 시그널을 받은 프로세스는 지정된 동작을 수행.
    - 시그널을 지정하지 않으면 프로세스를 종료시키는 15번 시그널을 보냄.
    - 사용자의 프로세스만 종료시킬 수 있음.
    - 관리자(root)는 모든 프로세스를 종료시킬 수 있음.

#### 시그널

* 프로세스에게 보내는 신호
* 프로세스는 시그널을 수신하면, 지정된 동작을 수행.

* 종류

| 시그널 번호 | 시그널 이름 | 기능  | 기본 응답 |
|-|-|-|-|
|1 | SIGNUP | 터미널 연결이 끊어진 경우에 발생 | 종료 |
|2 | SIGINT | 보통 ctrl + c 에 의해 발생 | 종료 |
|9 | SIGKILL | 프로세스를 강제종료 시킴 <br> 이 시그널은 무시할 수 없다. | 종료 |
|15 | SIGTERM | 프로세스를 종료 <br> 이 시그널은 무시할 수 있다. <br> kill 명령이 보내는 기본 시그널 | 종료 |


#### pkill

```bash
$ pkill [시그널] 프로세스명
```

* 프로세스의 명령 이름으로 프로세스를 찾아 지정한 시그널을 보냄
* 솔라리스에서만 제공
* 사용자가 소유한 프로세스만 종료 가능



### 프로세스 관리 도구

#### prstat

```bash
$ prstat [옵션] 
```

* 동작중인 프로세스의 통계 정보를 출력
* 프로세스 정보는 일정 시간 간격으로 자동 갱신
* 종료 : q
* 옵션
    - -a : 프로세스와 사용자에 대한 통계를 구분하여 출력.
    - -c : 중복하여 출력하지 않고, 기존 내용의 아래쪽에 새로운 정보를 출력.
    - -s키 : 키에 따라 정렬하여 출력.
    - -u euid : 해당 euid에 속한 프로세스 정보만 출력.
    - -U uid : 해당 uid에 속한 프로세스 정보만 출력.


### 포그라운드와 백그라운드 작업의 이해.

* 작업(job)
    - 쉘이 프로세스를 관리하는 단위
    - 쉘은 job을 시작시키고 제어 (job ID부여)
    - 유닉스의 프로세스는 포그라운드 작업과 백그라운드 작업으로 구분 가능.

* 포그라운드 처리
    - 사용자가 입력한 명령이 실행되어 결과가 출력될 때까지 프롬프트가 출력되지 않아서 다른 명령을 입력할 수 없는 처리 방법.
    - 보통은 끝날때까지 기다려야함.
* 백그라운드 처리
    - 명령의 입력이 끝나면 결과에 상관업이 바로 다음 프롬프트가 출력되어 다른 명령을 입력할 수 있는 처리 방법.
    - 명령의 끝에 &을 붙힘.

#### 작업 제어 명령 - jobs

```bash
$ jobs [옵션] 
```

* 작업 번호를 지정하지 않을시, 벡그라운드 작업이 모두 출력.
* 특정 작업 번호를 지정하면, 해당 작업의 정보만 출력
* 작업 번호 
    - %번호 : 해당 번호의 작업 정보를 출력.
    - %+ 또는 %%  : 작업순서가 +인 작업 정보를 출력.
    - %- : 작업 순서가 -인 작업 정보를 출력.

* jobs 명령 출력 목록

| 항목 | 출력 예 | 의미 |
|-|-|-|
| 작업 번호 | [1] | 작업번호로 백그라운드로 실행시킬 때마다 순차적으로 증가 |
| 작업 순서 | +/- | * + : 가장 최근에 접근한 작업 <br> * - : + 작업보다 바로 전에 접근한 작업 |
| 상태 | running | * 실행 중(running) : 현재 실행 중 <br> * 완료됨(done) : 작업이 정상 종료 <br> * 종료됨(terminated) : 작업이 비정상적 종료 <br> * 정지(stopped) : 작업이 잠시 중단 | 
| 명령 | sleep 100 &  | 백그라운드로 실행 중인 명령 |


### 작업 전환 및 종료 명령

| 명령 | 의미 |
|-|-|
| ctrl+z 또는 stop[%작업번호] |  포그라운드 작업을 중지(종료시키는 것이 아니라, 잠시 중단 하는 것) |
| bg[%작업 번호] | 작업 번호가 지시하는 작업을 백그라운드로 전환 | 
| fg[%작업 번호] | 작업 번호가 지시하는 작업을 포그라운드로 전환 |



### 작업 제어 명령 - nohup

```bash
$ nohup 명령 &
```
* 로그아웃을 한 뒤에도 백그라운드 작업을 계속 실행.
(원래는 로그아웃시, 실행중이던 모든 작업이 종료)
* 명령 실행결과와 오류메세지 : nohup.out 파일에 저장



## 사용자 정보 보기

### 로그인한 사용자 정보 보기

#### users

* 현재 시스템에 로그인 한 사용자명을 출력

#### who [옵션]

* 시스템을 사용하고 있는 사용자의 정보 출력.
* 옵션 
    - -q : 사용자명만 출력.
    - -H : 출력항목의 제목도 함께 출력.
    - -b : 마지막으로 재부팅한 날짜와 시간을 출력

#### w [사용자명]

* 로그인한 사용자 정보와 현재 작업의 정보 출력


### 사용자 자신의 정보 보기

#### who am I

* who 명령의 결과 중 자신에 대한 정보만 출력.

#### whoamI

* BSD 계열의 명령으로 솔라리스 11에서는 /usr/bin으로 통합
* 자신의 로그인 사용자명 출력.


### 사용자 전환하기

#### su [-] [사용자명]

* 아무 옵션 없이 사용하면, root 계정으로 변경
* 사용자명 지정 : 지정한 사용자로 변경
* \- : root 혹은 지정한 사용자의 초기화 파일이 실행되면서 작업 디렉토리도 사용자의 홈 디렉토리로 변경.


