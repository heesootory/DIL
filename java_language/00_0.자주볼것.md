# 객체지향언어

# 변수

* 멤버변수 
  - 인스턴스변수 + 클래스 변수
  - 초기화가 필요없음.
* 지역변수
  - 초기화 필수.

## static 
* 클래스메모리
* static 영역에 저장
* class 는 붙힐 수 없음.
* static 변수 = 공유 변수 = 클래스 변수 = 정적 변수
* static 메서드

## static 변수와 static 메서드

* 인스턴스를 생성하지 않아도 접근가능!!
* 클래스명.클래스변수 / 클래스명.클래스메서드 로 사용하자!
  

```java

class Card{
    String kind;
    int number;
    static int width = 100;
    static int height = 100;

    static void reverse(){
        System.out.println("뒤집기");
    }
}

public class Main{
    public static void main(String[] args) {
        System.out.println(Card.width);     // 100 출력

        Card.width = 20;
        Card.reverse();         // 뒤집기 출력

        System.out.println(Card.width);     // 50 출력

        Card c1 = new Card();
        Card.width = 10;            // 인스턴슬 생성 했더라도 static 변수는 클래스명을 사용하자.
        System.out.println(Card.width);     // 10 출력
        Card.reverse();          // 뒤집기 출력
    }

```

 > 인스턴스 변수/메서드 -> o static 변수/메서드

 > 인스턴스 변수/메서드 x <- static 변수/메서드


# 오버로딩

* 함수가 호출될 시점에!!!! 이름이 같은 함수중에 어떤 함수가 호출될지 결정할 수 잇어야 한다.
* 따라서, 모두 같지만 리턴타입만 다른 함수는 오버로딩이 아니다.
* 하지만, 매개변수의 순서만 달라져도 오버로딩으로 간주한다.



# 생성자





# 상속

## 상속관계 vs 포함관계

> 설계를 하다보면 정말 헷갈리는 부분이다. <br>
> 상속으로 받아야 할지, 포함으로 받아야 할지 고민하게 된다.<br>
> 외부에서 봤을때는 상속과 포함이 달라보이지 않지만, 객체를 생성해서 사용하는 유무가 있기때문에 그 의미가 다르다.

* 포함관계
  - 포함 관계는 class안에 객체를 생성해서 사용한다는 걸 잊지말자.
  - 따라서, 원도 여러 인스턴스가 생성될수 있고, 각각의 원들 안에 포함되어있는 점들도 전부 다른 인스턴스이다.
  - 객체가 옵션적으로 가지고 있을만한 요소는 포함관계로 생성한다.

```java
class Circle{
  Point c = new Point();
  int r;
}

```

* 상속관계
  - 객체가 필수적으로 당연시하게 가지고 있어야 할 요소는 상속관계로 생성한다.

```java
class Circle extends Point{
  int r;
}

```



* 원(Circle)과 점(Point)로 예를 들어 생각해보자.
    - 원은 점이다. -> 상속관계
    - 원은 점을 가지고 있다. -> 포함관계
    - "원은 점을 가지고 있다"라는 표현이 더 알맞으므로, 여기선 포함관계가 적절하다.

* 정리
    - ~은 -이다. (is - a) : 상속관계
    - ~은 -을 가지고 있다.(has - a) : 포함관계














