# 함수형 인터페이스와 람다 표현식



## 🌈 함수형 인터페이스 (Functional Interface)

<br>

* 추상 메소드를 딱 하나만 가지고 있는 인터페이스

* SAM (Single Abstract Method) 인터페이스

* @FuncationInterface 애노테이션을 가지고 있는 인터페이스


### 🐳 예시 코드

```java
@FunctionalInterface
public interface RunSomething {
    // abstract이 생략된 추상 메서드.
    void doIt();

    // public이 생략된 static 메서드.
    static void printNum(){
        System.out.println("heesoo");
    }

    // 디폴트 메서드
    default void printAge(){
        System.out.println("30");
    }
}
```

> 위의 인터페이스도 함수형 인터페이스이다.

> 여러 메서드가 존재하는 것과 무관하게, 추상 메서드는 1개 존재하므로, 함수형 인터페이스라고 할 수 있다.

> @FunctionalInterface 어노테이션은 @Override처럼 함수형 인터페이스인지 아닌지 가독성적으로 구별하는 기능과 이를 위반할 시, 에러를 보여주는 기능을 한다.

<br>


## 🌈  함수형 인터페이스를 사용하기와 람다 표현식(Lambda Expressions)

<br>

* 함수형 인터페이스의 인스턴스를 만드는 방법으로 쓰일 수 있다.

* 코드를 줄일 수 있다.

* 메소드 매개변수, 리턴 타입, 변수로 만들어 사용할 수도 있다.


<br>

### 🐳 함수형 인터페이스를 사용. (과거버젼) -> 람다 (java8)

<br>

* java 8 이전에는 "익명 내부 클래스"를 만들어서 사용.
    - 내부 클래스 (anonymous inner class) : 함수 내부에 정의하는 클래스로 포함하는 클래스 내부에서만 사용되기 때문에, 연관관계 생각없이 내부에 선언하여 직관적으로 사용하자는 취지.

    - 익명 클래스 : 클래스명을 정의하지 않은 클래스.

    ```java
    public class Foo {
        public static void main(String[] args) {
            // 익명 내부 클래스
            RunSomething runSomething = new RunSomething() {
                @Override
                public void doIt() {
                    // 추상 메서드 정의
                    System.out.println("Hello");
                }
            };
        }
    }
    ```

<br>

* java8 부터는 위의 익명 내부 클래스를 "람다"함수를 사용해서 표현.

    ```java
    public class Foo {
        public static void main(String[] args) {
            // 익명 내부 클래스 -> 람다
            RunSomething runSomething = () -> {
                // 추상 메서드 정의
                System.out.println("Hello");
            };
        }
    }
    ```

<br>
<br>


### 🐳 람다 함수 사용법

* 내부 구현 함수가 1줄일때

```java
public class Foo {
    public static void main(String[] args) {
        // 익명 내부 클래스 -> 람다
        RunSomething runSomething = () -> System.out.println("Hello");
        // 사용
        runSomething.doIt();
    }
}
```

* 내부 구현 함수가 여러줄일 때
    - 중괄호로 묶어주기

```java
public class Foo {
    public static void main(String[] args) {
        // 익명 내부 클래스 -> 람다
        RunSomething runSomething = () -> {
            System.out.println("Hello");
            System.out.println("Lambda");
        };
        // 사용
        runSomething.doIt();
    }
}
```

* 구현 함수가 매개변수와 리턴값이 존재할때

```java
@FunctionalInterface
public interface RunSomething {
    // abstract이 생략된 추상 메서드.
    int doIt(int number);
}

public class Foo {
    public static void main(String[] args) {
        // 익명 내부 클래스 -> 람다
        RunSomething runSomething = (number) -> {
            System.out.println("Hello");
            return number+10;
        };
        System.out.println(runSomething.doIt(1);
    }
}
```



<br>
<br>


## 🌈 자바에서 함수형 프로그래밍

<br>

* 함수를 First class object로 사용할 수 있다.
* 순수 함수 (Pure function)
    - 사이드 이팩트가 없다. (함수 밖에 있는 값을 변경하지 않는다.)- 상태가 없다. (함수 밖에 있는 값을 사용하지 않는다.)
* 고차 함수 (Higher-Order Function)
    - 함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수도 있다.
    - 불변성


<br>
<br>
<hr>
<br>
<br>

## 🌈 자바에서 제공하는 함수형 인터페이스

<br>


### 🐳 Java가 기본으로 제공하는 함수형 인터페이스

* java.util.function 패키지

* 자바에서 미리 정의해둔 자주 사용할만한 함수 인터페이스
* Function<T, R>
* BiFunction<T, U, R>
* Consumer<T>
* Supplier<T>
* Predicate<T>
* UnaryOperator<T>
* BinaryOperator<T>

<br>
<br>
<br>

### 🐳 Function<T, R>

* T 타입을 받아서 R 타입을 리턴하는 함수 인터페이스
    - 구현 메서드 : R apply(T t) 

* 함수 조합용 메소드
    - andThen
    - compose

* 함수형 인터페이스를 상속해서 만들기
    ```java
    public class Plus10 implements Function<Integer, Integer>{
        @Override
        public Integer apply(Integer integer) {
            return integer + 10;
        }
    }

    public class Foo {
        public static void main(String[] args) {
            Plus10 plus10 = new Plus10();
            System.out.println(plus10.apply(1));
        }
    }
    ```

* 람다 표현식 사용

    ```java
    public class Foo {
        public static void main(String[] args) {
            Function<Integer, Integer> plus10 = (i) -> i + 10;
            System.out.println(plus10.apply(1));
        }
    }
    ```

* 조합 메서드  compose 사용
    - 입력받은 함수를 먼저 수행하고, 앞의 함수를 수행(2를 곱하고, 10을 더한다.)
    ```java
    public class Foo {
        public static void main(String[] args) {
            Function<Integer, Integer> plus10 = (i) -> i + 10;
            Function<Integer, Integer> multiply2 = (i) -> i * 2;

            Function<Integer, Integer> multiply2AndPlus10 = plus10.compose(multiply2);

            System.out.println(multiply2AndPlus10.apply(2));
        }
    }
    /**
    *   14
    */
    ```

* 조합 메서드 andThen 사용
    - 앞의 함수를 먼저 수행후, 뒤의 함수(입력받은)를 실행.
    ```java
    public class Foo {
        public static void main(String[] args) {
            Function<Integer, Integer> plus10 = (i) -> i + 10;
            Function<Integer, Integer> multiply2 = (i) -> i * 2;

            Function<Integer, Integer> multiply2AndPlus10 = plus10.andThen(multiply2);

            System.out.println(multiply2AndPlus10.apply(2));
        }
    }
    /**
    *   24
    */
    ```

<br>
<br>
<br>

### 🐳 BiFunction<T, U, R>
* 두 개의 값(T, U)를 받아서 R 타입을 리턴하는 함수 인터페이스
    - R apply(T t, U u)

<br>

### 🐳 Consumer<T>
* T 타입을 받아서 아무값도 리턴하지 않는 함수 인터페이스
    - void Accept(T t)
        ```java
        public static void main(String[] args) {
                Consumer<Integer> printT = (i) -> System.out.println(i);
                printT.accept(10);
            }
        ```
* 함수 조합용 메소드
    - andThen

<br>

### 🐳 Supplier<T>
* T 타입의 값을 제공하는 함수 인터페이스
    - T get()
        ```java
            public static void main(String[] args) {
            Supplier<Integer> get10 = () -> 10;
            System.out.println(get10.get());
        }
        ```

<br>

### 🐳 Predicate<T>
* T 타입을 받아서 boolean을 리턴하는 함수 인터페이스
    - boolean test(T t)
* 함수 조합용 메소드
    - And
    - Or
    - Negate

```java
public static void main(String[] args) {
        /**
         * 문자열
         */
        Predicate<String> startWithHeesoo = (s) -> s.startsWith("heesoo");
        System.out.println(startWithHeesoo.test("heesoo choi"));    // true
        /**
         * 숫자형
         */
        Predicate<Integer> isEven = (i) -> i % 2 == 0;
        System.out.println(isEven.test(12));    // true
    }
```

<br>

### 🐳 UnaryOperator<T>
* Function<T, R>의 특수한 형태로, 입력값 하나를 받아서 동일한 타입을 리턴하는 함수 인터페이스
    - Function을 상속 받은 형태이므로, compose나 andThen도 사용가능.

```java
public static void main(String[] args) {
        UnaryOperator<Integer> plus10 = (i) -> i + 10;
        UnaryOperator<Integer> multiply2 = (i) -> i * 2;

        System.out.println(plus10.compose(multiply2).apply(2)); //14
    }
```
<br>

### 🐳 BinaryOperator<T>
* BiFunction<T, U, R>의 특수한 형태로, 동일한 타입의 입력값 두개를 받아 리턴하는 함수 인터페이스    
    - 3개의 타입이 모두 같은 경우라고 생각해서 만듬.











