# Socket IO 



## NC 란?

(NetCat)

* 가짜 서버, 가짜 클라이언트
    - 클라이언트 담당과 서버 담당이 각자 개발에 착수 하고, 서로 끝나는 시간이 다르다면, 각자 가짜의 클라나 서버를 만들어서 test해볼 수 있는 기능.

* 가짜 클라이언트 만들기

```vi
$ nc [IP주소] [port]
```

* 가짜 서버 만들기

```vi
$ nc -l [port]
```

> 먼저 nc를 만들어서 각자 localhost상에서 서버와 클라이언트 코드가 잘 동작하는지 확인해보기.

<br>
<br>
<br>

## 파일 입출력

### 리눅스의 특징

* 리눅스는 모든 것을 파일로 간주.
    - 디렉토리, 장치 etc...

* 소켓 또한 파일의 일종으로 취급
    - 즉, 소켓 조작은 파일 조작과 동일하게 간주.
    - 파일 입출력 함수를 소켓 입출력 함수(=네트워크 송수신)에 사용할 수 있다는 뜻.

* 네트워크 송수신 함수를 다시 해석하면 다음과 같다.
    - read() 사용 시 파일을 읽는다. -> "수신"한다. 즉, 데이터를 받는다.
    - write() 사용 시 파일에 쓴다. -> "송신"한다. 즉, 데이터를 보낸다.
    - 소켓 파일에 무엇인가 적으면 그대로 "송신"되며, 무엇인가 읽으면 그대로 "수신"된다는 뜻.
* Application 개발자는 소켓파일만 건드리면, 바로 소켓 통신이 가능하다.


### 파일 입출력 기본 함수들

* open() : 파일 열기
* read() : 파일 읽기
* write() : 파일 쓰기
* close() : 파일 닫기

### 리눅스의 특징 - 그림으로 이해하기

App ----------------------1------------------------>  네트워크 장치
  |  
  |--------------------2.File-----------------------> 


* 리눅스 세상에서 Application 이 커널의 함수를 직접 호출하는 것은 금지 되어있다.

* 커널에서 어떤 것을 부탁하고 싶을 때는
    - 방법1. System call
    - 방법2. 커널이 관리하는 특수 파일을 통하여 부탁하는 방법.

* 소켓 프로그래밍은 그 중,
    - 방법2, 특수한 파일에 접근하여 커널에게 요청을 하고 결과를 받는다.




### 파일 디스크립터(File Descripter)

* 소켓은 굉장히 복잡한 "파일"이다.

* 시스템으로부터 할당 받은 파일 또는 소켓에 부여된 정수를 파일 디스크립터라고 한다. (정수는 주솟값을 의미한다.)

* 복잡한 파일을 단순히 파일 디스크립터라는 정수로 "치환"하여 작업의 편의성을 높인 것.


### TCP 기반 서버/클라이언트 (암기하기)

#### 서버

* TCP 기반 서버에서 기본적인 함수 호출 순서는 다음과 같다.
    - socket() : 소켓생성
    - bind() : 소켓에 주소 할당
    - listen() : 클라이언트 연결 요청 대기
    - accept() : 클라이언트 연결 승인
    - read() /write() : 통신
    - close() : 소켓 닫기

* 소켓은 인터페이스, 다른말로 프레임워크이기 때문에, 반드시 위 과정을 암기해야함.

#### 클라이언트

* TCP 기반 클라이언트에서 기본적인 함수 호출 순서는 다음과 같다.
    - socket() : 소켓 생성
    - connect() : 연결 요청
    - read() / write() : 데이터 송수신
    - close() : 연결 종료

* 클라이언트는 서버와 프로그램의 목적이 다르기 때문에 다른 함수를 사용.
* 서버와 마찬가지로 위의 흐름도 반드시 암기해야 함.