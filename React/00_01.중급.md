# 중급 문법




## useEffect

* 어느시점에 부를지 결정하는 함수.

* 변화할때마다 다른 컴포넌트까지 렌더링하는걸 막아주는 방어막 역할을 한다고 볼 수 있음.

* useEffect(() => {호출되는 함수}, [변화 감지하는 변수])
    - 변화 감지하는 변수에 빈배열이 들어가면, 변화되는 값이 없기때문에 컴포넌트 생성시점에 렌더링될 시에만 호출됨.

```js
import {useState, useEffect} from "react";

function App() {
  const [counter, setValue] = useState(0);
  const [keyword, setKeyword] = useState("");
  const onClick = () => setValue((prev) => prev + 1);
  const onChange = (event) => setKeyword(event.target.value);
  console.log('i run all the time');
  useEffect(() => {console.log("CALL THE API......");}, []);
  // 한번만 호출(이 컴포넌트가 만들어진후, 첫번째랜더링만 호출)
  useEffect(() => {
    if(keyword !== "" && keyword.length > 5) console.log("SEARCH FOR", keyword);
  }, [keyword]);
  // keyword가 변할때마다 렌더링될시, 호출
  return (
    <div>
      <input value={keyword} onChange={onChange} type="text" placeholder="Search here...."/>
      <h1>{counter}</h1>
      <button onClick={onClick}>click me</button>
    </div>
  );
}

export default App;

```


## CleanUp function

* 컴포넌트도 생명주기가 있으므로, 실행될때와 종료될때 모두 존재하고, 그걸 이용할 수 있다.


* 예제코드
    - 컴포넌트 실행시점 : hiFunc
    - 종료시점 : byeFunc

```js
import {useState, useEffect} from "react";

function Hello(){
  function byeFunc() {
    console.log("destroyed :(");
  }
  function hiFunc() {
    console.log("created :)");
    return byeFunc;
  }
  useEffect(hiFunc, []);

  return <h1>Hello</h1>;
}

function App() {
  const [showing, setShowing] = useState(false);

  const onClick = () => {
    setShowing((prev) => !prev);
  }

  return (<div>
    {showing ? <Hello /> : null}
    <button onClick={onClick}>{showing ? "Hide" : "Show"}</button>
  </div>);
}

export default App;

```



## 배열로 리스트만들기(todolist 만들기)

* map함수를 이용해서 <li> 태그 그리기.
    - react.js 에서는 map함수 각각의 원소에 고유id(key)를 지정해야 함.

```js
import {useState, useEffect} from "react";

function App() {
  const [toDo, setToDo] = useState("");
  const [toDos, setToDos] = useState([]);
  const onChange = (event) => setToDo(event.target.value);
  const onSubmit = (event) => {
    event.preventDefault();
    if(toDo === ""){
      return;   // toDo가 비었다면 동작X.
    }
    setToDos((currentArray) => [toDo, ...currentArray]);
    setToDo("");    // 제출뒤, input 비우기.
  }
  console.log(toDos);
  return (
    <div>
      <h1>My To Dos ({toDos.length})</h1>
      <form onSubmit={onSubmit}>
        <input onChange={onChange} value={toDo} type="text" placeholder="Write your to do..."/>
        <button>Add To Do</button>
      </form>
      <hr />
      <ul>
        {toDos.map((item, index) => <li key={index}>{item}</li>)}
      </ul>
    </div>);
}

export default App;



```


## fetch api 호출 후, 로딩시점 구분해서 렌더링

```js
import {useState, useEffect} from "react";

function App() {
  const [loading, setLoading] = useState(true);
  const [coins, setCoins] = useState([]);
  // useEffet를 이용해서 한번만 받아오기.
  useEffect(() => {
    fetch("https://api.coinpaprika.com/v1/tickers")
      .then((res) => res.json())
      .then((json) => {
        setCoins(json);
        setLoading(false);
      });
  }, []); 

  return (
    <div>
      <h1>The Coins! {loading ? "" : `(${coins.length})`}</h1>
      // 아직 못받아왓을시, loading... / 받아올시, 그려주기
      {loading ? 
        <strong>Loading...</strong> 
        : <select>
            {coins.map((coin) => (
              <option>
                {coin.name}({coin.symbol}) : {coin.quotes.USD.price} USD
              </option>
            ))}
          </select>}
      
    </div>
  );

}

export default App;




```