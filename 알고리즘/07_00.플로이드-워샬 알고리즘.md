# 플로이드-워샬 알고리즘




## 🌈 개념

* 이 문제를 해결하려면, 각 정점을 시작정점으로 정하여 다익스트라의 최단 경로 알고리즘을 수행하면 된다.

* 이때의 시간복잡도는 인접행렬을 사용하면, O(n<sup>3</sup>)이다. 단, n은 정점의 갯수.
    - 다익스트라와 시간복잡도가 동일.
    - 그러나 플로이드는 알고리즘은 매우 간단하여 다익스트라 알고리즈을 사용하는 것보다 효율적임.

* Warshall은 그래프에서 모든 쌍의 경로 존재 여부를 찾아내는 동적 계획 알고리즘을 제안했고, Floyd는 이를 변형하여 모든 쌍 최단 경로를 찾는 알고리즘을 고안.

* 따라서 모든 쌍 최단 경로를 찾는 동적 계획 알고리즘을 플로이드-워샬 알고리즘이라 한다.

<br>
<br>

## 🌈 특징

* 동적 계획 알고리즘으로 모든 쌍 최단 경로 문제를 해결하려면, 먼저 부분 문제들을 찾아야 한다.

* 이를 위해 일단 그래프의 정점의 수가 적을 떄를 생각해보자.

* 주요 아이디어
    - 경유 가능한 정점들을 정점 1로 부터 시작하여, 정점1과 2, 그 다음엔 정점 1,2,3으로 하나씩 추가하여, 마지막에는 정점 1~n까지의 모든 정점을 경유 가능한 정점들로 고려하면서, 모든 쌍의 최단경로의 거리를 계산하는 것이다.

* 부분문제 정의
    - 입력 그래프의 정점을 각각 1,2,3 ... ,n 이라 할때,
    - D<sub>ij</sub><sup>k</sup> = 정점(1,2,...,k)만을 경유 가능한 정점들로 고려하여, 정점 i로 부터 정점 j까지의 모든 경로 중에서 가장 짧은 경로의 거리.

* 주의할점은 정점1에서 정점k까지의 모든 정점들을 반드시 경유하는 경로를 의미하는 것이 아니다.

* 간단하게 dp적으로 생각해본다면, dp테이블은 모든 시작정점과 도착정점에 대해서 계속해서 최단 경로를 갱신하고, 또한 그 최단경로를 이용한(경유한) 다른 노드와 노드 사이의 최단경로를 갱신하므로, 결국 모든 경로의 최단 경로들을 구하게 된다.
    - 경유안하는 경우 -> 정점1을 경유할때 -> ... -> 정점 k-1 고려 최단경로 -> 정점k까지 고려 최단경로 -> 정점 k+1 고려  최단경로.


<br>
<br>

## 🌈 코드 구현

* "경찰과 도둑" -> 경.출.도 !

```java
for(int k = 1; k < n + 1; k++){     // 경
        for(int i = 1; i < n + 1; i++){     // 출
            for(int j = 1; j < n + 1; j++){     // 도
                dp[i][j] = Math.min(dp[i][k] + dp[k][j], dp[i][j]);
            }
        }
    }
```