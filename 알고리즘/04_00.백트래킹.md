# 백트래킹




## 특징

*  = "퇴각 검색"
* 모든 조합을 시도해서 문제의 해를 찾는다.
* 해를 얻을때까지 모든 가능성을 시도.
* 모든 가능성은 하나의 트리처럼 구성할 수 있으며, 가지(선택지) 중에 해결책이 있다.
    - <mark>상태 공간 트리</mark>
* 여러 가지(선택지)들이 존재하는 상황에서 하나의 가지를 선택.
* 선택이 이루어지면 새로운 선택지들의 집합이 생성.
* 이런 선택을 반복하면서 최종 상태에 도달.
* 보통 재귀 함수로 구현.
* 시간 복잡도
    - 선택지<sup>재귀 깊이</sup> = 선택지<sup>n</sup>
    - 보통 지수 형태의 시간복잡도를 갖기 때문에, 시간이 오래걸린다.



## 백트래킹 기법

* 어떤 노드의 유망성을 점검한 후에 유망(promising)하지 않다고 결정되면 그 노드의 부모로 되돌아가(backtracking) 다음 자식 노드로 간다.
    - 답이 될 가능성이 있는! 후보들만 탐색하는 기법이다.

* 유망하다
    - 어떤 노드를 방문하였을 때, 그 노드를 포함한 경로가 해답이 될 수 있다면 유망하다고 한다.

* 가지치기 (pruning)
    - 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다.


## 백트래킹을 이용한 알고리즘의 절차

1. 상태 공간 트리의 깇이 우선 검색을 실시.

2. 각 노드가 유망한지를 점검.

3. 만일 그 노드가 유망하지 않으면 , 그 노드의 부모노드로 돌아가서 다른 노드로의 검색을 계속한다.



## 백트래킹과 완전탐색(DFS)의 차이

* 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임 - 가지치기

* 완전 탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로를 조기에 차단.

* 완전 탐색을 가하기에는 경우의 수가 너무나 많다.
( 예를 들어, N!가지의 경우의 수를 가진 문제에 대해 완전 탐색을 가하면 당연히 처리 불가능한 문제.)

* 백트래킹 알고리즘을 적용하면 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우에는 여전히 지수함수 시간을 요하므로 처리 불가능할 수 있다.

* 가지치기가 만능이 아니다!!!

* 가치치기의 상황이 상태공간트리의 리프노드 쪽에서 일어날 경우 -> 가지치기 효과가 없다!!


## 백트래킹 연습

### N - Queen 문제

* 같은 행에 퀸을 놓지않는다고 생각한다면, 이차원 배열이 아닌 일차원 배열로도 가능하다!
    - 일차원배열읜 인덱스를 각 행으로 보고, 각 배열에 열의 위치를 저장.
    - 각 행마다 같은 열과 대각선을 체크하면 됨.


*  

























