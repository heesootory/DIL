# 쿼리 메서드 기능


<br>
<br>
<br>

## 🌈 쿼리 메서드 기능 3가지

* 메서드 이름으로 쿼리 생성. 🍀

* 메서드 이름으로 JPA NamedQuery 호출(자주 사용❌).

* @Query 어노테이션을 사용해서 레퍼지토리 인터페이스에 쿼리 직접 정의. 🍀


<br>
<br>

## 🌈 1. 메서드 이름으로 쿼리 생성


<br>
<br>

> 메서드 이름을 분석해서 JPQL 쿼리 실행.

* 예시
    ```java
    List<Member> findByUsernameAndAgeGreaterThan(String username, int age);
    // Username 기반으로 일치 + Age가 age보다 큰 row 조회
    ```


* 쿼리 메소드 필터 조건 
    - [공식문서](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation)

* 조회 : find...By, read...By, query...By, get...By
    - [공식문서](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation)
    - By 는 뒤에 조건이 더 붙는 다는 의미로, By를 붙이지 않는다면 전체 조회한다.
    - ... 부분은 아무 이름이나 넣어도 해당 엔티티를 조회한다.

* COUNT : count...By /  반환타입 : long
* EXISTS : exists...By / 반환타입 : boolean
* 삭제 : delete...By, remove...By / 반환타입 : long
* DISTINCT : findDistinct, findMemberDistinctBy
    ```java
    List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
    List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);
    // DISTINCT 는 해당 column 앞,뒤 무관.
    ```
* LIMIT : findFirst3, findFirst, findTop, findTop3
    - [공식문서](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.limit-query-result)


> 참고 : 이 기능은 엔티티의 필드명이 변경되며너 인터페이스에 정의한 메서드 이름도 꼭 함께 변경해야함. 그렇지 않으면 애플리케이션을 시작하는 시점에 오류 발생.<br>
이렇게 애플리케이션 로딩 시점에 오류를 인지할 수 있는 것이 스프링 데이터 JPA의 매우 큰 장점. 🍀

> 이름이 너무 길어지면 오히려 복잡해질수 있기 때문에 쿼리의 조건이 많아질 경우에는 3번 기능인 JPQL를 직접 짜는 방식으로 구현하자.

<br>
<br>
<br>
<hr>
<br>
<br>

## 🌈 3. @Query, 리포지토리 메소드에 쿼리 정의하기

<br>
<br>

> 실무에서는 메서드 이름으로 쿼리 생성 기능은 파라미터가 증가하면 메서드 이름이 매우 지저분해진다. 따라서 @Query 기능을 자주 사용하게됨.

* @org.springframework.data.jpa.repository.Query 어노테이션 사용.

* 실행할 메서드에 정적 쿼리를 직접 작성하므로 <mark>이름 없는 Named 쿼리</mark>라 할 수 있음

* JPA Named 쿼리처럼 애플리케이션 실행 시점에 문법 오류를 발견할 수 있음(매우 큰 장점!)🍀

```java
@Query("select m from Member m where m.username = :username and m.age = :age")
List<Member> findUser(@Param("username") String username, @Param("age") int
age);
```

<br>
<br>


### 🐳 @Query, 값, DTO 조회하기

<br>

> 여태까지는 모두 엔티티를 조회해서 가져왔는데, 단순히 값이나 DTO를 조회할 때 사용하는 방법.

#### 🎯 기본 값 타입

<br>

```java
@Query("select m.username from Member m")
List<String> findUsernameList();
```

* 엔티티를 가져오는 방식은 Member 같은 엔티티 타입의 리스트를 반환했지만, 위와 같이 String 타입의 리스트로 받으면, username의 이름 전부를 단순히 리스트로 받아올 수 있다.

* JPA 값 타입(@Embedded)도 이 방식으로 조회 가능.

<br>
<br>

#### 🎯 DTO 타입

<br>

```java
// DTO 생성

@Data
  public class MemberDto {
      private Long id;
      private String username;
      private String teamName;

      public MemberDto(Long id, String username, String teamName) {
          this.id = id;
          this.username = username;
          this.teamName = teamName;
      }
}
```
```java
// Repository

@Query("select new study.datajpa.dto.MemberDto(m.id, m.username, t.name) " +
          "from Member m join m.team t")
List<MemberDto> findMemberDto();
```

* DTO로 직접 조회 하려면 new 명령어를 사용.
    - new study.datajpa.dto.MemberDto(m.id, m.username, t.name) 는 실제로 DTO클래스의 생성자에 해당한다. 따라서 생성자가 존재해야함.

<br>
<br>
<br>

### 🐳 파라미터 바인딩

<br>


* 위치 기반 -> 사용 ❌
* 이름 기반 

```java
 select m from Member m where m.username = ?0 //위치 기반 
 select m from Member m where m.username = :name //이름 기반
````

> 코드 가독성과 유지보수를 위해 <mark>이름 기반</mark>파라미터 바인딩을 사용하자!!!

```java
@Query("select m from Member m where m.username = :name")
Member findMembers(@Param("name") String username);
```


#### 🎯 컬렉션 파라미터 바인딩

* Collection 타입으로 in 절 지원.
    - in절 뒤에오는 리스트에 있는 이름들을 포함하는 것을 조회 가능.

```java
@Query("select m from Member m where m.username in :names")
List<Member> findByNames(@Param("names") List<String> names);
```


<br>
<br>
<br>

### 🐳 반환 타입

<br>

> 스프링 데이터 JPA는 유연한 반환 타입을 지원. [공식문서](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-return-types)

```java
List<Member> findByUsername(String name); //컬렉션 
Member findByUsername(String name); //단건
Optional<Member> findByUsername(String name); //단건 Optional
```

* 함수명에 반환타입을 적는것은 안적어도 되고, 매우 유연하게 설정되어 있으므로 아무 명사로 적어도됨.
    - 위의 함수명들을 다음과 같이 변경해도 무관.
        - findListByUsername
        - findMemberByUsername
        - findOptionalByUsername


#### 🎯 조회 결과가 많거나 적을때!!

* 컬렉션
    - 결과 없음 : 빈 컬렉션 반환 -> 전혀 문제가 되지 않음.

* 단건 조회
    - 결과 없음 : null반환 -> 결과가 있거나 없거나의 문제면 Optional 단건조회를 사용하자.
    ```java
    Optional<Member> findMember = memberRepository.findOptionalByUsername("heesoo");
    // 자바8 문법을 적극 활용하자.
    ```
    - 결과가 2건 이상 : javax.persistence.NonUniqueResultException 예외 발생

    
<br>
<br>
<br>


### 🐳 페이징과 정렬

<br>
<br>
<br>

#### 🐋 순수 JPA 페이징과 정렬

<br>

* JPQL 기반 페이징 + 정렬 예시코드

> 검색 조건: 나이가 10살<br>
> 정렬 조건: 이름으로 내림차순 <br>
> 페이징 조건: 첫 번째 페이지, 페이지당 보여줄 데이터는 3건

```java
// 페이징 + 정렬
public List<Member> findByPage(int age, int offset, int limit) {
        return em.createQuery("select m from Member m where m.age = :age order by
    m.username desc")
                .setParameter("age", age)
       
 }
.setFirstResult(offset)
.setMaxResults(limit)
.getResultList();

// 카운트
public long totalCount(int age) {
    return em.createQuery("select count(m) from Member m where m.age = :age",
Long.class)
}
.setParameter("age", age)
.getSingleResult();
```

* test 코드

```java
@Test
  public void paging() throws Exception {
//given
      memberJpaRepository.save(new Member("member1", 10));
      memberJpaRepository.save(new Member("member2", 10));
      memberJpaRepository.save(new Member("member3", 10));
      memberJpaRepository.save(new Member("member4", 10));
      memberJpaRepository.save(new Member("member5", 10));
      int age = 10;
      int offset = 0;
      int limit = 3;
//when
      List<Member> members = memberJpaRepository.findByPage(age, offset, limit);
      long totalCount = memberJpaRepository.totalCount(age);
//페이지 계산 공식 적용...
// totalPage = totalCount / size ...
// 마지막 페이지 ... // 최초 페이지 ..
//then
      assertThat(members.size()).isEqualTo(3);
 
       assertThat(totalCount).isEqualTo(5);
}
```

<br>
<br>

#### 🐋 스프링 데이터 JPA 페이징과 정렬

* 페이징 정렬 파라미터
    - org.springframework.data.domain.Sort : 정렬 기능
    - org.springframework.data.domain.Pageable : 페이징 기능 (내부에 Sort 포함)

* 특별한 반환 타입
    - org.springframework.data.domain.Page : 추가 count 쿼리 결과를 포함하는 페이징
        - contents 쿼리와 totalCount 쿼리가 함께 나감.
    - org.springframework.data.domain.Slice : 추가 count 쿼리 없이 다음 페이지만 확인 가능 (내부적으로 limit + 1조회)
        - 페이지가 정확히 나타나지 않고, 더보기 기능으로 추가 데이터를 보게하는 형식에서 사용.
    - List (자바 컬렉션): 추가 count 쿼리 없이 결과만 반환

```java
// Pageable 에 page할 조건을 삽입.
Page<Member> findByUsername(String name, Pageable pageable); //count 쿼리 함께 사용 

Slice<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안함

List<Member> findByUsername(String name, Pageable pageable); //count 쿼리 사용 안함

List<Member> findByUsername(String name, Sort sort);
```

#### 🎯 page 사용시

* 사용예시 코드
    - 스프링 데이터 레포지토리
    ```java
    public interface MemberRepository extends Repository<Member, Long> {
            
        Page<Member> findByAge(int age, Pageable pageable);
    }
    ```

    - test 코드
    ```java
    /페이징 조건과 정렬 조건 설정
    @Test
    public void page() throws Exception {
    //given
        memberRepository.save(new Member("member1", 10));
        memberRepository.save(new Member("member2", 10));
        memberRepository.save(new Member("member3", 10));
        memberRepository.save(new Member("member4", 10));
        memberRepository.save(new Member("member5", 10));
    
    //when
        PageRequest pageRequest = PageRequest.of(0, 3, Sort.by(Sort.Direction.DESC,
    "username"));   // page 조건 설정
        Page<Member> page = memberRepository.findByAge(10, pageRequest);
    
    //then
    List<Member> content = page.getContent(); //조회된 데이터 
    assertThat(content.size()).isEqualTo(3); //조회된 데이터 수 - 페이지 당 갯수.
    assertThat(page.getTotalElements()).isEqualTo(5); //전체 데이터 수 - totalCount쿼리도 동시에 나가기 때문에 바로 뽑아낼 수 있음.
    assertThat(page.getNumber()).isEqualTo(0); //페이지 번호 
    assertThat(page.getTotalPages()).isEqualTo(2); //전체 페이지 번호 
    assertThat(page.isFirst()).isTrue(); //첫번째 항목인가? 
    assertThat(page.hasNext()).isTrue(); //다음 페이지가 있는가?
    }
    ```

* 두 번째 파라미터로 받은 Pageable 은 인터페이스
    - 실제 사용할 때는 해당 인터페이스를 구현한 org.springframework.data.domain.PageRequest 객체를 사용.

* Page는 1부터 시작이 아니라 0부터 시작이다.


#### 🎯 Slice 사용시 page와의 차이점

* 위의 page 예시 코드에서 한 페이징당 limit를 3으로 날리면, Slice에서는 1를 더한 4를 요청하는 쿼리를 날림.

* totalCount 쿼리를 함께 날리지 않으므로, 아래 두쿼리는 불가. -> 나머지 쿼리는 모두 동일하게 사용가능.

```java
assertThat(page.getTotalElements()).isEqualTo(5);
assertThat(page.getTotalPages()).isEqualTo(2);
```

#### 🎯 List 를 사용시

* page 기능으로 사용했던 쿼리들의 모든 함수 사용불가. 
    - 순수한 페이징 기능만 구현.


#### 🎯 고려할 사항.















