# 중급 문법



<br>
<br>
<br>

## 🌈 프로젝션과 결과 반환 - 기본

<br>

> 프로젝션 이란?? : select 대상 지정.

* 프로젝션 대상이 하나일때
    - 타입을 명확하게 지정할 수 있음.
    - 기본타입(String) 이거나 엔티티 타입 하나(member)

* 예시코드

```java
// 프로젝션 : member.username/ 프로젝션 타입 : String
List<String> result = queryFactory
          .select(member.username)
          .from(member)
          .fetch();
```

<br>
<br>

* 프로젝션 타입이 둘 이상 일때
    - 튜플이나 DTO 사용.
        - 튜플 : Querydsl이 여러개 타입을 받을 수 있게 만들어 놓은 타입.
    - com.querydsl.core.Tuple 사용.
        - 🍀 튜플 타입은 리포지토리 계층 안에서 사용하는 건 괜찮치만, service나 controller까지 넘어가는 설계를 하는 건 좋지 않다. -> 그래야 하부 계층(리포지토리)를 다른 기술로 바꾸더라도 다른 계층에 영향을 안미치게 설계가 가능하기 때문! 🍀 -> 나갈 때는 DTO변환해서 나가자.

* 예시코드

```java
List<Tuple> result = queryFactory
                        .select(member.username, member.age)
                        .from(member)
                        .fetch();
  
    for (Tuple tuple : result) {
        String username = tuple.get(member.username);
        Integer age = tuple.get(member.age);
        System.out.println("username=" + username);
        System.out.println("age=" + age);
}
```


<br>
<br>
<hr>
<br>
<br>

## 🌈 프로젝션과 결과 반환 - DTO 조회

<br>

* DTO로 조회를 한다는 의미는 DTO에 만들어 놓은 생성자에 맞게 (마치 원하는 통을 만들어 놓고 담는 느낌) 그것만 조회해서 알맞게 퍼올린다는 의미이다.

<br>
<br>


### 🐳 순수 JPA에서 DTO 조회.

* 순수 JPA 에서는 DTO로 조회시, 마치 생성자를 생성하는 것 처럼 new명령어를 사용해야한다.

* 단점 : DTO의 package 이름을 다 적어줘야해서 지저분함.

* 생성자 방식만 지원.

* 예시코드
     - DTO
        ```java
        package study.querydsl.dto;

        import lombok.Data;

        @Data
        public class MemberDto {
            private String username;
            private int age;

            public MemberDto() {}

            public MemberDto(String username, int age) {
                this.username = username;
                this.age = age;
            } 
        }
        ```
    - 순수 JPA (new operation을 활용한 방법)
        ```java
        List<MemberDto> result = em.createQuery(
            "select new study.querydsl.dto.MemberDto(m.username, m.age) " +
            "from Member m", MemberDto.class)
            .getResultList();
        ```

<br>
<br>

### 🐳 Querydsl 빈 생성(Bean population)

<br>

* 3가지 방법을 지원.
    - 프로퍼티 접근
    - 필드 직접 접근.
    - 생성자 사용.


* 프로퍼티 접근 - setter 사용
    - MemberDto에 해당 필드변수명의 setter가 존재해야함.
    - Projections.bean 사용.
    - MemberDto에 기본생성자가 존재해야 가능!


        ```java
        List<MemberDto> result = queryFactory
                                    .select(Projections.bean(MemberDto.class,
                                            member.username,
                                            member.age))
                                    .from(member)
                                    .fetch();
        ```

* 필드 직접 접근
    - MemberDto에 setter가 없어도 필드의 변수에 바로 꽂아버림.
    - Projections.fields 사용
        
        ```java
        List<MemberDto> result = queryFactory
                                    .select(Projections.fields(MemberDto.class,
                                            member.username,
                                            member.age))
                                    .from(member)
                                    .fetch();
        ```


* 생성자 사용
     - Projections.fields 사용.
     - MemberDto에 알맞은 생성자는 존재해야 함.
     - 가져오려는 변수와 MemberDto의 필드변수의 타입이 정확히 일치하면 가능.(변수명이 안맞아도 타입에 매치되서 들어감)

        ```java
        List<MemberDto> result = queryFactory
                                    .select(Projections.constructor(MemberDto.class,
                                            member.username,
                                            member.age))
                                    .from(member)
                                    .fetch();
        ```

* 예외상황
    - 별칭이 다를때
        - username.as("memberName") : 필드에 별칭 적용
    - 엔티티에 없는 값을 바로 DTO로 집어 넣어야 할때
        - ExpressionUtils.as(source,alias) : 필드나, 서브 쿼리에 별칭 적용
        ```java
        package study.querydsl.dto;
        import lombok.Data;

        @Data
        public class UserDto {
            private String name;
            private int age;
        }

        List<UserDto> fetch = queryFactory
        .select(Projections.fields(UserDto.class,
                member.username.as("name"),  // 별칭이 다를때
                ExpressionUtils.as(         // 서브쿼리로 값 만들어서 넣기
                        JPAExpressions
                                .select(memberSub.age.max())
                                .from(memberSub), "age")

                )
        ).from(member)
        .fetch();
        ```










