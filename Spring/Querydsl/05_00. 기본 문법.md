# 기본 문법


<br>
<br>
<br>

## 🌈 JPQL vs Querydsl 비교

<br>

* JPQL: 문자(runtime 시점 오류) / Querydsl: 코드(컴파일 시점 오류)

* JPQL : 파라미터 바인딩 직접 / Querydsl : 파라디터 바인딩 자동 처리.



* JPQL

    ```java
    @Test
    public void startJPQL() {
        //member1을 찾아라.
        String qlString =
            "select m from Member m " +
            "where m.username = :username";

        Member findMember = em.createQuery(qlString, Member.class)
                                .setParameter("username", "member1")
                                .getSingleResult();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
    ```

* Querydsl

    - EntityManager 로 JPAQueryFactory 생성
    - Querydsl은 JPQL 빌더
    - JPAQueryFactory queryFactory = new JPAQueryFactory(em); 를 필드로 가져도 동시성 문제가 없게 설계되었다.(스프링 프레임워크에서 주입해주는 엔티티 매니저가 멀티 쓰레드가 가능하게 설계됨.)

    ```java
    @Test
    public void startQuerydsl() {
        //member1을 찾아라.
        JPAQueryFactory queryFactory = new JPAQueryFactory(em);
        QMember m = new QMember("m");

        Member findMember = queryFactory
        .select(m)
        .from(m)
        .where(m.username.eq("member1"))//파라미터 바인딩 처리
        .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
    ```

<br>
<br>
<hr>
<br>
<br>


## 🌈 기본 Q-Type 활용

<br>

* Q클래스 인스턴스를 사용하는 2가지 방법
    - 같은 테이블을 조인하는 경우에만 별칭을 직접 지정해서 사용하고, 대부분의 경우 기본인스턴스를 사용하자!
    ```java
    QMember qMember = new QMember("m"); //별칭 직접 지정
    QMember qMember = QMember.member; //기본 인스턴스 사용
    ```


* 기본 인스턴스를 static import와 함께 사용.

```java
import static study.querydsl.entity.QMember.*;

@Test
public void startQuerydsl3() {
    //member1을 찾아라.
    Member findMember = queryFactory
                    .select(member)
                    .from(member)
                    .where(member.username.eq("member1"))
                    .fetchOne();
                    
    assertThat(findMember.getUsername()).isEqualTo("member1");
}
```

* JPQL 쿼리로 확인하기
    - 결국 Querydsl도 JPQL 쿼리로 바뀐 후 처리 된다.
    - Querydsl 은 JPQL의 빌더 역할!
    - yml 파일에 추가하면 실행되는 JQPL을 볼 수 있다.
        ```java
        spring.jpa.properties.hibernate.use_sql_comments: true
        ``` 


<br>
<br>
<hr>
<br>
<br>


## 🌈 검색 조건 쿼리


<br>

* select 과 from 은 합쳐서 selectFrom으로 사용가능.

* 조건문 where
    - and 나 or을 이용해서 메서드 체인으로 연결 가능.

* 예시 코드
    ```java
    @Test
    public void search() {
        Member findMember = queryFactory
                            .selectFrom(member)
                            .where(member.username.eq("member1")
                            .and(member.age.eq(10)))
                            .fetchOne();

        assertThat(findMember.getUsername()).isEqualTo("member1");
    }
    ```

* AND 조건은 -> ","(콤마) 로 처리 가능.
    - 콤마 중간에 들어오는 null은 무시한다. -> 추후 동적 쿼리를 만들때 깔끔하게 짤 수 있다.




<br>
<br>

### 🐳 JPQL이 제공하는 모든 검색 조건 제공

```java
member.username.eq("member1") // username = 'member1'
member.username.ne("member1") //username != 'member1'
member.username.eq("member1").not() // username != 'member1'
member.username.isNotNull() //이름이 is not null

member.age.in(10, 20) // age in (10,20)
member.age.notIn(10, 20) // age not in (10, 20)
member.age.between(10,30) //between 10, 30
member.age.goe(30) // age >= 30
member.age.gt(30) // age > 30
member.age.loe(30) // age <= 30
member.age.lt(30) // age < 30

member.username.like("member%") //like 검색
member.username.contains("member") // like ‘%member%’ 검색
member.username.startsWith("member") //like ‘member%’ 검색
```


<br>
<br>
<hr>
<br>
<br>



## 🌈 결과 조회

* fetch() : 리스트 조회, 데이터 없으면 빈 리스트 반환
* fetchOne() : 단 건 조회
    - 결과가 없으면 : null
    - 결과가 둘 이상이면 : com.querydsl.core.NonUniqueResultException
* fetchFirst() : limit(1).fetchOne() ->  처음 한건 조회.
* fetchResults() : 페이징 정보 포함, total count 쿼리 추가 실행
* fetchCount() : count 쿼리로 변경해서 count 수 조회



* 예시 코드
    ```java
    //페이징에서 사용 -  페이징에서 활용될 수 있는 다양한 함수들을 활용.
    QueryResults<Member> results = queryFactory
    .selectFrom(member)
    .fetchResults();

    results.getTotal(); // 카운트만 출력.
    List<Member> content = results.getResults();    // 리스트로 출력.


    //count 쿼리로 변경
    long count = queryFactory
    .selectFrom(member)
    .fetchCount();

    ```


<br>
<br>
<hr>
<br>
<br>

## 🌈 정렬

<br>

* 주요 함수 정리
    - desc(), asc() : 일반 정렬.
    - nullsLast(), nullsFirst() : null 데이터 순서 부여.

* 예시코드

```java
/**
* 회원 정렬 순서
* 1. 회원 나이 내림차순(desc)
* 2. 회원 이름 올림차순(asc)
* 단 2에서 회원 이름이 없으면 마지막에 출력(nulls last)
*/
@Test
public void sort() {
    em.persist(new Member(null, 100));
    em.persist(new Member("member5", 100));
    em.persist(new Member("member6", 100));

    List<Member> result = queryFactory
                            .selectFrom(member)
                            .where(member.age.eq(100))
                            .orderBy(member.age.desc(), member.username.asc().nullsLast())
                            .fetch();

    Member member5 = result.get(0);
    Member member6 = result.get(1);
    Member memberNull = result.get(2);

    assertThat(member5.getUsername()).isEqualTo("member5");
    assertThat(member6.getUsername()).isEqualTo("member6");
    assertThat(memberNull.getUsername()).isNull();
}
```


<br>
<br>
<hr>
<br>
<br>

## 🌈 페이징

<br>


* 예시코드
    - 조회 건수 제한.
        ```java
        @Test
        public void paging1() {
            List<Member> result = queryFactory
                                    .selectFrom(member)
                                    .orderBy(member.username.desc())
                                    .offset(1) //0부터 시작(zero index)
                                    .limit(2) //최대 2건 조회
                                    .fetch();

            assertThat(result.size()).isEqualTo(2);
        }
        ```

    - 전체 조회 수가 필요할때
        - count 쿼리가 먼저 실행된 후에 content에 관한 쿼리가 나감.
        - 실제로는 데이터를 조회하는 쿼리는 여러 테이블을 조인해야 하지만, count쿼리는 조인이 필요없는 경우도 존재할 수 있다.(left outer join) 그런데 이렇게 자동화된 count 쿼리는 원본 쿼리와 같이 모두 조인을 해버리기 때문에 성능 문제가 발생할 수 있다. count쿼리에 조인이 필요없는 성능 최적화가 필요하다면, count전용 쿼리를 별도로 작성하자.
    
    ```java
    @Test
    public void paging2() {
        QueryResults<Member> queryResults = queryFactory
                                            .selectFrom(member)
                                            .orderBy(member.username.desc())
                                            .offset(1)
                                            .limit(2)
                                            .fetchResults();

        assertThat(queryResults.getTotal()).isEqualTo(4);
        assertThat(queryResults.getLimit()).isEqualTo(2);
        assertThat(queryResults.getOffset()).isEqualTo(1);
        assertThat(queryResults.getResults().size()).isEqualTo(2);
    }
    ```


<br>
<br>
<hr>
<br>
<br>

## 🌈 집합

<br>














