# Session and Cookie


<br>

## index




<br>



---


<br>




## Session

> 브라우저와 백엔드 사이의 memeory, history 같은 존재.

> 이게 작동하려면, 백엔드와 브라우저가 서로에 대한 정보를 가지고 있어야 함.

### Stateless(무상태)

> 로그인이 성공한 후에, home으로 이동을 하게 되는데, get요청에 의해 백엔드가 html를 render하고 나면, 브라우저와 백엔드의 연결을 끊어지게 되고, 로그인된 정보는 기억하지 못하게 되는데, 이런 상태를 말한다.

> 한번 연결 되었다가 끝나는것. 둘 사이의 연결 state가 없는 상태.


> 따라서, 우리는 유저에게 원가를 남겨서, 백엔드가 요청을 할 때마다, 누가 요청을 하는지 알 수 있게해야 함. -> 작은 텍스트

> 로그인 할때마다, 백엔드는 유저에세 "작은 텍스트"를 줄 것이고, 그 이후에도 유저한테 요청을 보낼때마다, 그 텍스트도 같이 보내달라고 하는것.


### express-session

[https://www.npmjs.com/package/express-session](https://www.npmjs.com/package/express-session)

```bash
npm i express-session
```

![d](/Image/Express/s1.PNG)
![d](/Image/Express/s2.PNG)

> session 미들웨어 추가.

> 이 미들웨어가 이제 사이트로 들어오는 모두를 기억하게 됨.

> 로그인 하지 않았어도 히스토리에 남게되고, 로그인을 한 사람은 "작은 텍스트"를 준다.

![d](/Image/Express/s3.PNG)
![d](/Image/Express/s4.PNG)


> 검사 창에서 쿠키를 확인해보면, 새로고침할시, 이제부터 서버가 우리 브라우저를 기억할 수 있는, "작은 텍스트"를 건네준걸 확인 가능.

![d](/Image/Express/s5.PNG)
![d](/Image/Express/s6.PNG)


> 새로고침으로 페이지를 요청할 때마다, 이런 쿠키가 자동으로 보내지게 된다.

> 콘솔에서도, request.header 정보에서 쿠키가 들어간 것을 볼 수 있다.

![d](/Image/Express/s7.PNG)
![d](/Image/Express/s8.PNG)
![d](/Image/Express/s9.PNG)

> 새로고침 1에서는 [Object: null prototype] 로 뜨던게, 
> 새로고침 2에서는 uVCRMcFtNU5TpzNkafjotBO7FgzL4twu: 라는 세션이 존재하는 걸 볼수 있고, 브라우저 검색에서도 똑같은 텍스트가 뜬다.

> 🔥백엔드 서버에서 우리의 브라우저를 구별하는 id라고 생각할 수 있다.🔥

> 새로운 브라우저를 켜서 다시 확인하게 되면, 다른 id값을 준것을 확인할 수 있다.


* edge internet으로도 들가보자.
  
![d](/Image/Express/s10.PNG)
![d](/Image/Express/s11.PNG)

> 다른 브라우저로 서버에 들어갔으므로, 또 다른 id가 부여되었다. -> 세션 전달.

> 이게 바로 백엔드 서버가 id를 통해 브라우저를 기억하고, 구별하는 방법!!

> 쿠키안에 그 id가 존재한다.

> 세션 object => '세션id' :{cookie : {}}

> 🔥세션id는 세션 object 맨처음에 등장하는데, 이상하게도 cookie안에도 포함되어있다!

* 현재는 fakeDB 만들었을때 처럼, 서버를 껐다가 다시 키면, 세션들이 모두 사라지게된다.

* 추후에 mongoDB와 세션을 연결해서, 백엔드 서버가 잊지 않도록 할 수 있다.
* "작은 텍스트" = 세션 id
* 세션과 세션id가 백엔드 서버가 브라우저를 기억하는 방법!!
* 세션 id를 가지고 있으면, 세션 object에 다른 정보를 추가 시킬 수 있다.


### session object

![d](/Image/Express/s12.PNG)

> 새로운 url을 파서 session정보를 전달해보자.

![d](/Image/Express/s13.PNG)

> 크롬과 엣지의 브라우저 각각 고유의 id가 전달됨.


* counter로 확인 해보자.

![d](/Image/Express/s14.PNG)

> 임의로, 변수하나를 넣고 counter역할 ㄱ.

![d](/Image/Express/s15.PNG)
![d](/Image/Express/s16.PNG)

> 새로고침마다, 수가 증가 -> 서로 다른 브라우져가 다른 값을 세션에 담고 있다.

> 🔥 각각의 세션DB에 객체들이 저장된다는 것을 알 수 있다.
> 🔥  따라서, 우리가 세션을 유지시키면, 세션DB안에 모든 정보를 집어넣고, 다닐수 있다.


### 정리

> 🔥 백엔드 서버가 브라우저에게 세션id를 부여.<br>
> 🔥  브라우저가 쿠키에 그 세션ID를 저장.<br>
> 🔥 express에서도 그 세션에 대한 정보를 세션DB에 저장.<br>
> 🔥 브라우저가 요청시 마다, 쿠키에서 세션id를 가져와 보내준다.<br>
> 🔥 서버가 그 세션id를 읽고,  브라우저를 구별,확인.<br>




## Logged in User

> 로그인 유저를 저장해보자.

> 유저가 로그인을 하면, 그 유저에 대한 정보를 세션에 담기.

![d](/Image/Express/s17.PNG)

> 로그인이 true 이고, user정보를 session에 저장!

![d](/Image/Express/s18.PNG)

> 로그인 전 세션DB.

![d](/Image/Express/s19.PNG)

> 로그인 후 세션DB.

> 다른 페이지로 이동해도! 같은 세션object가 이동되는걸 볼 수 있다!!!



## template과 session 

> template에서 세션을 정보를 받아와야, login버튼을 보여줄지 logout버튼을 보여줄지 결정할 수 있다.


![d](/Image/Express/s20.PNG)
![d](/Image/Express/s21.PNG)

> res에는 기본적으로 locals라는 객체가 담겨가는데, 브라우저에서 자동으로 제공하는 공간이다.

> 이 local공간은 template에서도 확인이 가능하다.

![d](/Image/Express/s22.PNG)
![d](/Image/Express/s23.PNG)

> locals 같은 객체명을 안쓰고도, template에서 쉽네 접근이 가능.

> 또 전역변수라서, templates 어디에서든 사용가능!

>> 이 방식으로 template과 정보를 공유하면됨.

### localMiddleWare

> local에 저장할 정보는 미들웨어를 통해 따로 저장.

![d](/Image/Express/s24.PNG)
![d](/Image/Express/s25.PNG)
![d](/Image/Express/s26.PNG)

> 주의할 점은 session 을 만들어 준다음에, 미들웨어를 사용해야 한다는 것!!

![d](/Image/Express/s28.PNG)

> req.session에서 들어온 로그인 정보를, res.locals에 저장하고, 확인해보자.

> 이제 locals에 session 정보가 저장된걸 확인했으니, templates에서 사용할 수 있다.

![d](/Image/Express/s29.PNG)

> base 페이지 정리.

![d](/Image/Express/s30.PNG)

> 유저 객체를 locals에 넘겨주자.

> loggedInUser 이 값은 아마 로그아웃되어있을경우에는, undefined


![d](/Image/Express/s31.PNG)
> 유저 객체를 받아왔으니, 그 정보를 바탕으로 프로필을 볼 수 있게.

![d](/Image/Express/s32.PNG)

> 로그인 시 홈페이지.






















