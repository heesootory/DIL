# Comment section

<br>

## index

<br>



---

<br>




## Schema (DB model)

![api](/Image/Express/a1.png)
![api](/Image/Express/a2.png)
![api](/Image/Express/a3.png)

> video, user model은 여러개의 comment를 가질 수 있으므로, 배열[]로, Schema를 생성.



## comment front - 프론트단 js

![api](/Image/Express/a4.png)

> Webpack의 Url 정리.

![api](/Image/Express/a5.png)

> 불러올 template에 import

![api](/Image/Express/a6.png)

> 댓글을 submit 한 후, 브라우저의 기본동작을 preventDefault로 막아줌.

![api](/Image/Express/a7.png)


> dataset에 어느 비디오인지에 대한 정보 들어있음.

> 누가 댓글의 주인인지 프론트엔드에서 알려준다면, 보안에 취약해지므로, 댓글의 주인은 session으로 알려주면 됨.

![api](/Image/Express/a8.png)

> 로그인 했을때만, 댓글을 볼 수 있게 하려면, 댓글에 대한 프론트 js도 if문으로 분기처리 해줘야함. 아니면 프론트js에서 queryselctor를 찾지 못하는 에러가 남.


> 혹은

![api](/Image/Express/a10.png) 

> 프론트 js 를 수정해서 처리 - form 이 존재할때만, 프론트가 동작하게 만들기.

### 프론트엔드에서 백엔드로 정보 전달 

![api](/Image/Express/a9.png) 

> fetch를 사용해 url로 request하기 (fetch는 js를 통해 request를 하게 도와줌.)

![api](/Image/Express/a12.png)

> Router 생성

![api](/Image/Express/a13.png)

> app.use(express.text())를 이용해서, text를 request로 전달 가능.

❄️ but! text뿐만 아니라, 여러 데이터를 전달해야 한다면!?

🔥 express의 string을 받아서, json으로 바꿔주는 미들웨어를 사용해야 함!!

![api](/Image/Express/a11.png)

> 이 과정을 진행하는 것!!

> json 미들웨어를 사용하면 위와 같은 과정이 뒷작업으로 이루어지는데

> 이 미들웨어를 사용하기 위해선, 우리가 보내는 string 문자열이 사실은 json을 위한 string 이고, json 미들웨어를 사용해야해! 라고 알려줘야함.

![api](/Image/Express/a14.png)

> fetch에서 전달하는 정보로 header에는 request데 대한 기본정보를 담아놓는 곳.

![api](/Image/Express/a15.png)





















